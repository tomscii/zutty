/* -*- C++ -*-
 * This file is part of Zutty.
 * Copyright (C) 2020 Tom Szilagyi
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * See the file LICENSE for the full license.
 */

#include "log.h"
#include "pty.h"

#include <algorithm>
#include <sstream>

// for the debug/step facility:
#include <chrono>
#include <thread>
#include <sys/types.h>
#include <signal.h>

namespace zutty {

#ifdef DEBUG

   inline void
   Vterm::debugKey ()
   {
      switch (debugStep)
      {
      case 0: debugStep = 1; break;
      case 1: debugStep = 10; break;
      case 10: debugStep = 100; break;
      case 100: debugStep = 0; break;
      }
      debugCnt = debugStep;
      logT << "*** DEBUG step=" << debugStep << std::endl;
   }

   inline void
   Vterm::debugBreak ()
   {
      if (!debugStep || --debugCnt > 0)
         return;

      debugCnt = debugStep;
      logT << "*** DEBUG STOP (step=" << debugStep << "), "
           << readPos + 1 - lastStopPos << " bytes since last:\n        "
           << dumpBuffer (inputBuf + lastStopPos, inputBuf + readPos + 1);
      lastStopPos = readPos + 1;

      logT << "Issue 'kill -CONT " << getpid () << "' or 'fg' to continue."
           << std::endl;

      redraw ();
      using namespace std::chrono_literals;
      std::this_thread::sleep_for (100ms);

      kill (getpid (), SIGSTOP);
   }

   #define DEBUG_BREAK debugBreak()
   #define TRACE_FUN                                                      \
      do {                                                                \
         logT << __FUNCTION__ << " [";                                    \
      for (size_t k = 0; k < nInputOps; ++k) {                            \
         if (k) {                                                         \
            vlog << ";";                                                  \
         }                                                                \
         vlog << inputOps [k];                                            \
      }                                                                   \
      vlog << "] \t"                                                      \
           << "p(" << posY << "," << posX << ")  "                        \
           << "d(" << nRows << "," << nCols << ")  "                      \
           << "mgn[" << cf->marginTop << "," << cf->marginBottom << ")  " \
           << "hmgn:" << horizMarginMode                                  \
           << " [" << hMargin << "," << nColsEff                          \
           << ")  cur=" << cur << "  head=" << cf->scrollHead             \
           << std::endl;                                                  \
   } while (0)
#else
   #define DEBUG_BREAK
   #define TRACE_FUN
#endif // DEBUG

   inline void
   Vterm::unhandledInput (char ch)
   {
      logE << "Unhandled input char '" << ch
           << "' (" << (unsigned int)ch << ") in state " << (int)inputState
           << ". Escape sequence so far: "
           << dumpBuffer (inputBuf + lastEscBegin, inputBuf + readPos + 1);
      setState (InputState::Normal);
   }

   inline void
   Vterm::traceNormalInput ()
   {
   #ifdef DEBUG
      if (lastNormalBegin < readPos)
      {
         auto dumpbufs = dumpBuffer (inputBuf + lastNormalBegin,
                                     inputBuf + readPos);
         if (dumpbufs.length ())
         {
            logT << "Inserted: " << dumpbufs;
         }
      }
      lastNormalBegin = readPos + 1;
   #endif // DEBUG
   }

   inline void
   Vterm::redraw ()
   {
      cf->selection = snapSelection (selection, selectSnapTo);
      onRefresh (* cf);
   }

   inline const MouseTrackingState&
   Vterm::getMouseTrackingState () const
   {
      return mouseTrk;
   }

   inline void
   Vterm::setHasFocus (bool hasFocus_)
   {
      hasFocus = hasFocus_;
      showCursor ();
      redraw ();
   }

   inline void
   Vterm::mouseWheelUp ()
   {
      if (altScrollMode && altScreenBufferMode)
      {
         inputOps [0] = 1;
         nInputOps = 1;
         writePty (VtKey::Up);
      }
   }

   inline void
   Vterm::mouseWheelDown ()
   {
      if (altScrollMode && altScreenBufferMode)
      {
         inputOps [0] = 1;
         nInputOps = 1;
         writePty (VtKey::Down);
      }
   }

   inline void
   Vterm::resetTerminal ()
   {
      resetScreen ();
      resetAttrs ();
      fillScreen (' ');

      switchColMode (ColMode::C80);

      cf->scrollHead = 0;
      cf->marginTop = 0;
      cf->marginBottom = nRows;
      cf->cursor.color = defaultFgPalIx < 0
                       ? opts.fg
                       : palette256 [defaultFgPalIx];
      posX = 0;
      posY = 0;
      setCur ();

      switchScreenBufferMode (false);
      altScrollMode = opts.altScrollMode;

      horizMarginMode = false;
      hMargin = 0;
      nColsEff = nCols;

      setState (InputState::Normal);
   }

   inline void
   Vterm::resetScreen ()
   {
      showCursorMode = true;
      autoWrapMode = true;
      autoNewlineMode = false;
      insertMode = false;
      bkspSendsDel = true;
      localEcho = false;
      bracketedPasteMode = false;

      compatLevel = CompatibilityLevel::VT400;
      cursorKeyMode = CursorKeyMode::ANSI;
      keypadMode = KeypadMode::Normal;
      originMode = OriginMode::Absolute;
      charsetState = CharsetState {};

      savedCursor_SCO.isSet = false;
      savedCursor_DEC->isSet = false;

      mouseTrk = MouseTrackingState {};

      tabStops.clear ();
      selection.clear ();
   }

   inline void
   Vterm::resetAttrs ()
   {
      reverseVideo = false;
      fg = &attrs.fg;
      bg = &attrs.bg;

      inputOps [0] = 0;
      nInputOps = 1;
      csi_SGR ();
   }

   inline void
   Vterm::clearScreen ()
   {
      posX = 0;
      posY = 0;
      setCur ();
      fillScreen (' ');
   }

   inline void
   Vterm::fillScreen (uint16_t ch)
   {
      for (int k = 0; k < nRows * nCols; ++k)
      {
         (* cf) [k] = attrs;
         (* cf) [k].uc_pt = ch;
      }
   }

   inline void
   Vterm::invalidateSelection (const Rect&& damage)
   {
      if (selection.empty ())
         return;

      const Rect& sel = cf->selection;
      if (sel.br <= damage.tl || damage.br <= sel.tl)
         return;

      selection.clear ();
   }

   inline void
   Vterm::vscrollSelection (int vertOffset)
   {
      if (selection.empty ())
         return;

      int y1 = selection.tl.y + vertOffset;
      int y2 = selection.br.y + vertOffset;

      if (y1 < cf->marginTop ||
          y2 > cf->marginBottom ||
          (y2 == cf->marginBottom && selection.br.x > 0))
      {
         selection.clear ();
         return;
      }

      // N.B.: y-coord is snap-invariant; need to keep these in sync here
      cf->selection.tl.y = selection.tl.y = y1;
      cf->selection.br.y = selection.br.y = y2;
   }

   inline Rect
   Vterm::snapSelection (Rect sel, SelectSnapTo snapTo)
   {
      if (sel.empty ())
         return sel;

      if (sel.rectangular)
         return sel;

      switch (snapTo)
      {
      case SelectSnapTo::Char:
         break;
      case SelectSnapTo::Word:
         while (sel.tl.x < nCols &&
                cf->getCell (sel.tl.y, sel.tl.x).uc_pt == ' ')
            ++sel.tl.x;
         while (sel.tl.x > 0 &&
                cf->getCell (sel.tl.y, sel.tl.x - 1).uc_pt != ' ')
            --sel.tl.x;

         while (sel.br.x > 0 &&
                cf->getCell (sel.br.y, sel.br.x).uc_pt == ' ')
            --sel.br.x;
         while (sel.br.x < nCols &&
                cf->getCell (sel.br.y, sel.br.x).uc_pt != ' ')
            ++sel.br.x;
         break;
      case SelectSnapTo::Line:
         sel.tl.x = 0;
         sel.br.x = nCols;
         break;
      default: break;
      }
      return sel;
   }

   inline void
   Vterm::switchColMode (ColMode colMode_)
   {
      if (colMode == colMode_)
         return;

      resetScreen ();
      clearScreen ();

      if (colMode_ == ColMode::C80)
      {
         logT << "DECCOLM: Selected 80 columns per line" << std::endl;
      }
      else
      {
         logT << "DECCOLM: Selected 132 columns per line" << std::endl;
      }

      colMode = colMode_;
   }

   inline void
   Vterm::switchScreenBufferMode (bool altScreenBufferMode_)
   {
      if (altScreenBufferMode == altScreenBufferMode_)
         return;

      if (altScreenBufferMode_)
      {
         frame_alt = Frame (winPx, winPy, nCols, nRows);
         cf = &frame_alt;

         savedCursor_DEC = &savedCursor_DEC_alt;
         altScreenBufferMode = true;
      }
      else
      {
         frame_pri.resize (winPx, winPy, nCols, nRows);
         cf = &frame_pri;
         frame_alt.freeCells ();

         savedCursor_DEC_alt.isSet = false;
         savedCursor_DEC = &savedCursor_DEC_pri;
         altScreenBufferMode = false;
         selection.clear ();
      }
   }

   inline void
   Vterm::setState (InputState newState)
   {
      if (newState == inputState)
         return;

      if (newState == InputState::Normal)
      {
         DEBUG_BREAK;
         nInputOps = 0;
         inputOps [0] = 0;
         lastNormalBegin = readPos + 1;
      }
      else if (inputState == InputState::Normal)
      {
         traceNormalInput ();
      }

      inputState = newState;
   }

   inline int
   Vterm::writePty (uint8_t ch, VtModifier modifiers)
   {
      auto uch = (unsigned char*)&ch;
      logT << "pty write (mod=" << (int)modifiers << "): "
           << dumpBuffer (uch, uch + 1);
      if ((modifiers & VtModifier::alt) != VtModifier::none)
      {
         static uint8_t wbuf [2] = { '\e', '\0' };
         wbuf [1] = ch;
         if (localEcho)
         {
            static uint8_t pbuf [4] = { '^', '[', '\0', '\0' };
            uint8_t k = 3;
            if (ch >= ' ')
               pbuf [2] = ch;
            else
            {
               pbuf [2] = '^';
               pbuf [3] = ch + 0x40;
               k = 4;
            }
            logT << "pty pbuf: " << dumpBuffer (pbuf, pbuf + k);
            processInput (pbuf, k);
         }
         return write (ptyFd, wbuf, 2);
      }
      else
      {
         if (localEcho)
            processInput (uch, 1);
         return write (ptyFd, &ch, 1);
      }
   }

   inline int
   Vterm::writePty (const char* cstr)
   {
      auto ucstr = (unsigned char*)cstr;
      auto len = strlen (cstr);
      logT << "pty write: " << dumpBuffer (ucstr, ucstr + len);
      if (localEcho)
         processInput (ucstr, len);
      return write (ptyFd, cstr, len);
   }

   inline void
   Vterm::readPty ()
   {
      ssize_t n = read (ptyFd, inputBuf, sizeof (inputBuf));

      logT << "pty read: " << dumpBuffer (inputBuf, inputBuf + n);
      processInput (inputBuf, n);
   }

   inline uint32_t
   Vterm::setCur ()
   {
      curPosViaCharPlacement = false;
      cur = cf->getIdx (posY, posX);
      return cur;
   }

   inline void
   Vterm::normalizeCursorPos ()
   {
      if (nColsEff < posX + 1)
         posX = nColsEff - 1;

      if (nRows < posY + 1)
         posY = nRows - 1;

      setCur ();
   }

   inline uint32_t
   Vterm::startOfThisLine ()
   {
      return cur - posX;
   }

   inline uint32_t
   Vterm::startOfNextLine ()
   {
      return cur - posX + nCols;
   }

   // N.B.: Only use this to erase (within) one line.
   // Use a series of eraseRow () calls to erase larger areas!
   inline void
   Vterm::eraseRange (uint32_t start, uint32_t end)
   {
      CharVdev::Cell* ca = &((* cf) [start]);
      CharVdev::Cell*const cz = ca - start + end;
      while (ca < cz)
         *ca++ = attrs;
   }

   inline void
   Vterm::eraseRow (uint16_t pY)
   {
      uint32_t idx = cf->getIdx (pY, 0);
      eraseRange (idx + hMargin, idx + nColsEff);
      invalidateSelection (Rect (hMargin, pY, nColsEff, pY));
   }

   inline void
   Vterm::copyRow (uint16_t dstY, uint16_t srcY)
   {
      uint32_t dstIdx = cf->getIdx (dstY, hMargin);
      uint32_t srcIdx = cf->getIdx (srcY, hMargin);
      cf->copyCells (dstIdx, srcIdx, nColsEff - hMargin);
      invalidateSelection (Rect (hMargin, dstY, nColsEff, dstY));
   }

   // insert blank rows at and below startY, within the scrolling area
   inline void
   Vterm::insertRows (uint16_t startY, uint16_t count)
   {
      for (uint16_t pY = cf->marginBottom - count - 1; pY >= startY; --pY)
      {
         copyRow (pY + count, pY);
         if (!pY) break;
      }

      for (uint16_t pY = startY; pY < startY + count; ++pY)
         eraseRow (pY);
   }

   // delete rows at and below startY, within the scrolling area
   inline void
   Vterm::deleteRows (uint16_t startY, uint16_t count)
   {
      for (uint16_t pY = startY; pY < cf->marginBottom - count; ++pY)
         copyRow (pY, pY + count);

      for (uint16_t pY = cf->marginBottom - count; pY < cf->marginBottom; ++pY)
         eraseRow (pY);
   }

   // insert blank cols at and to the right of startX, within the scrolling area
   inline void
   Vterm::insertCols (uint16_t startX, uint16_t count)
   {
      for (uint16_t r = cf->marginTop; r < cf->marginBottom; ++r)
      {
         cf->moveCells (nCols * r + startX + count, nCols * r + startX,
                        nColsEff - startX - count);
         eraseRange (nCols * r + startX, nCols * r + startX + count);
      }
      invalidateSelection (Rect (startX, cf->marginTop,
                                 nColsEff, cf->marginBottom));
   }

   // delete cols at and to the right of startX, within the scrolling area
   inline void
   Vterm::deleteCols (uint16_t startX, uint16_t count)
   {
      for (uint16_t r = cf->marginTop; r < cf->marginBottom; ++r)
      {
         cf->moveCells (nCols * r + startX, nCols * r + startX + count,
                        nColsEff - startX - count);
         eraseRange (nCols * r + nColsEff - count, nCols * r + nColsEff);
      }
      invalidateSelection (Rect (startX, cf->marginTop,
                                 nColsEff, cf->marginBottom));
   }

   inline void
   Vterm::inputGraphicChar (unsigned char ch)
   {
      if ((ch & 0x80) == 0)
      {
         utf8dec.checkPrematureEOS ();

         // GL range
         Charset cs;
         if (charsetState.ss)
         {
            cs = charsetState.g [charsetState.ss];
            charsetState.ss = 0;
         }
         else
            cs = charsetState.g [charsetState.gl];

         if (cs == Charset::UTF8)
            utf8dec.onUnicode (ch < 127 ? ch : 0);
         else if (ch >= 32 && (cs == Charset::IsoLatin1 || ch < 127))
            utf8dec.onUnicode (charCodes [(uint8_t)cs] [ch - 32]);
      }
      else
      {
         // GR range
         Charset cs = charsetState.g [charsetState.gr];
         if (cs == Charset::UTF8)
            utf8dec.pushByte (ch);
         else if (ch >= 160 && (cs == Charset::IsoLatin1 || ch < 255))
            utf8dec.onUnicode (charCodes [(uint8_t)cs] [ch - 160]);
      }
   }

   inline void
   Vterm::placeGraphicChar ()
   {
      if (curPosViaCharPlacement && (posX == nColsEff || posX == nCols))
      {
         if (! autoWrapMode) return;
         (* cf) [cur - 1].wrap = 1;
         inp_CR ();
         inp_LF ();
      }

      if (insertMode)
      {
         nInputOps = 1;
         inputOps [0] = 1;
         csi_ICH ();
      }

      auto& c = (* cf) [cur];
      c = attrs;
      c.uc_pt = utf8dec.getUnicode ();
      invalidateSelection (Rect (posX, posY));

      ++posX;
      setCur ();
      curPosViaCharPlacement = true;
    }

   inline void
   Vterm::inp_LF ()
   {
      TRACE_FUN;
      if (esc_IND ())
         eraseRange (cur, cur - posX + nColsEff);
   }

   inline void
   Vterm::inp_CR ()
   {
      TRACE_FUN;
      posX = hMargin;
      setCur ();
   }

   inline void
   Vterm::jumpToNextTabStop ()
   {
      if (tabStops.empty ())
      {
         // Hard default of 8 chars limited to right margin
         do
         {
            posX = ((posX / 8) + 1) * 8;
         } while (posX < hMargin);
         posX = std::min ((int)posX, nColsEff - 1);
      }
      else
      {
         // Next tabstop column set, or the right margin
         auto ts = std::lower_bound (tabStops.begin (), tabStops.end (), posX);
         posX = (ts == tabStops.end ()) ? nCols - 1 : * ts;
      }
      setCur ();
   }

   inline void
   Vterm::inp_HT ()
   {
      TRACE_FUN;
      if (posX == nColsEff)
      {
         inp_CR ();
         esc_IND ();
      }
      else
         jumpToNextTabStop ();
   }

   inline void
   Vterm::showCursor ()
   {
      TRACE_FUN;
      if (showCursorMode)
      {
         cf->cursor.posX = posX;
         cf->cursor.posY = posY;
         using CS = CharVdev::Cursor::Style;
         cf->cursor.style = hasFocus ? CS::filled_block : CS::hollow_block;
      }
   }

   inline void
   Vterm::hideCursor ()
   {
      TRACE_FUN;
      using CS = CharVdev::Cursor::Style;
      cf->cursor.style = CS::hidden;
   }

   inline void
   Vterm::esc_DCS (unsigned char fin)
   {
      TRACE_FUN;

   #ifdef DEBUG
      logT << "Designate Character Set: destination '" << scsDst
           <<"', charset '";
      if (scsMod)
      {
         vlog << scsMod;
      }
      vlog << fin << "'" << std::endl;
   #endif

      uint8_t ix = 0;
      bool cs96 = false;
      switch (scsDst)
      {
      case '(': ix = 0; break;
      case ')': ix = 1; break;
      case '*': ix = 2; break;
      case '+': ix = 3; break;
      case '-': ix = 1; cs96 = true; break;
      case '.': ix = 2; cs96 = true; break;
      case '/': ix = 3; cs96 = true; break;
      }

      Charset cs = Charset::UTF8;
      switch (fin)
      {
      case 'A': cs = cs96 ? Charset::IsoLatin1 : Charset::IsoUK; break;
      case 'B': cs = Charset::UTF8; break;
      case '0': cs = Charset::DecSpec; break;
      case '5':
         if (scsMod == '%')
            cs = Charset::DecSuppl;
         break;
      case '<': cs = Charset::DecUserPref; break;
      case '>': cs = Charset::DecTechn; break;
      }

      charsetState.g [ix] = cs;
      setState (InputState::Normal);
   }

   inline bool
   Vterm::esc_IND ()
   {
      TRACE_FUN;
      bool scrolled = false;
      if (posY == cf->marginBottom - 1)
      {
         nInputOps = 1;
         inputOps [0] = 1;
         csi_SU ();
         scrolled = true;
      }
      else if (posY < nRows - 1)
      {
         ++posY;
         setCur ();
      }
      setState (InputState::Normal);
      return scrolled;
   }

   inline void
   Vterm::esc_RI ()
   {
      TRACE_FUN;
      if (posY == cf->marginTop)
      {
         nInputOps = 1;
         inputOps [0] = 1;
         csi_SD ();
      }
      else if (posY > 0)
      {
         --posY;
         setCur ();
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ecma48_SL ()
   {
      TRACE_FUN;
      int arg = inputOps [0] ? inputOps [0] : 1u;
      arg = std::min (arg, nColsEff - hMargin);
      deleteCols (hMargin, arg);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ecma48_SR ()
   {
      TRACE_FUN;
      int arg = inputOps [0] ? inputOps [0] : 1u;
      arg = std::min (arg, nColsEff - hMargin);
      insertCols (hMargin, arg);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DECIC ()
   {
      TRACE_FUN;
      int arg = inputOps [0] ? inputOps [0] : 1u;
      if (posX >= hMargin && posX < nColsEff &&
          posY >= cf->marginTop && posY < cf->marginBottom)
      {
         arg = std::min (arg, nColsEff - posX);
         insertCols (posX, arg);
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DECDC ()
   {
      TRACE_FUN;
      int arg = inputOps [0] ? inputOps [0] : 1u;
      if (posX >= hMargin && posX < nColsEff &&
          posY >= cf->marginTop && posY < cf->marginBottom)
      {
         arg = std::min (arg, nColsEff - posX);
         deleteCols (posX, arg);
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_FI ()
   {
      TRACE_FUN;
      nInputOps = 1;
      inputOps [0] = 1;
      if (posX < nColsEff - 1)
         csi_CUF ();
      else
         csi_ecma48_SL ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_BI ()
   {
      TRACE_FUN;
      nInputOps = 1;
      inputOps [0] = 1;
      if (posX > hMargin)
         csi_CUB ();
      else
         csi_ecma48_SR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_NEL ()
   {
      TRACE_FUN;
      esc_IND ();
      posX = 0;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_HTS ()
   {
      TRACE_FUN;
      tabStops.push_back (posX);
      std::sort (tabStops.begin (), tabStops.end ());
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SCOSC_SLRM ()
   {
      if (horizMarginMode)
         csi_SLRM ();
      else
         csi_SCOSC ();
   }

   inline void
   Vterm::csi_SCOSC ()
   {
      TRACE_FUN;
      savedCursor_SCO.posX = posX;
      savedCursor_SCO.posY = posY;
      savedCursor_SCO.isSet = true;
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SCORC ()
   {
      TRACE_FUN;
      if (!savedCursor_SCO.isSet)
      {
         logI << "Asked to restore cursor (SCORC) but it has not been saved."
              << std::endl;
      }
      else
      {
         posX = savedCursor_SCO.posX;
         posY = savedCursor_SCO.posY;
         normalizeCursorPos ();
         savedCursor_SCO.isSet = false;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_DECSC ()
   {
      TRACE_FUN;
      savedCursor_DEC->posX = posX;
      savedCursor_DEC->posY = posY;
      savedCursor_DEC->attrs = attrs;
      savedCursor_DEC->autoWrapMode = autoWrapMode;
      savedCursor_DEC->originMode = originMode;
      savedCursor_DEC->charsetState = charsetState;
      savedCursor_DEC->isSet = true;
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_DECRC ()
   {
      TRACE_FUN;
      if (!savedCursor_DEC->isSet)
      {
         logI << "Asked to restore cursor (DECRC) but it has not been saved."
              << std::endl;
      }
      else
      {
         posX = savedCursor_DEC->posX;
         posY = savedCursor_DEC->posY;
         normalizeCursorPos ();
         attrs = savedCursor_DEC->attrs;
         autoWrapMode = savedCursor_DEC->autoWrapMode;
         originMode = savedCursor_DEC->originMode;
         charsetState = savedCursor_DEC->charsetState;
         savedCursor_DEC->isSet = false;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUU ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      if (posY >= cf->marginTop)
         arg = std::min ((int)arg, posY - cf->marginTop);
      else
         arg = std::min (arg, posY);
      posY -= arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUD ()
   {
      TRACE_FUN;
      int arg = inputOps [0] ? inputOps [0] : 1;
      if (posY < cf->marginBottom)
         arg = std::min (arg, cf->marginBottom - posY - 1);
      else
         arg = std::min (arg, nRows - posY - 1);
      posY += arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUF ()
   {
      TRACE_FUN;
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, nColsEff - posX - 1);
      posX += arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUB ()
   {
      TRACE_FUN;
      int arg = inputOps [0] ? inputOps [0] : 1;
      if (posX >= hMargin)
         arg = std::min (arg, posX - hMargin);
      else
         arg = std::min (arg, (int)posX);
      if (posX == nColsEff)
         arg = std::min (arg + 1, (int)posX);
      posX -= arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CNL ()
   {
      TRACE_FUN;
      csi_CUD ();
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CPL ()
   {
      TRACE_FUN;
      csi_CUU ();
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CHA ()
   {
      TRACE_FUN;
      uint16_t col = inputOps [0] ? inputOps [0] : 1;
      col = std::max ((uint16_t)1, std::min (col, nCols));
      posX = col - 1;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_HPA ()
   {
      TRACE_FUN;
      csi_CHA ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_HPR ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      inputOps [0] = posX + arg + 1;
      csi_CHA ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_VPA ()
   {
      TRACE_FUN;
      uint16_t row = inputOps [0] ? inputOps [0] : 1;
      row = std::max ((uint16_t)1, std::min (row, nRows));
      posY = row - 1;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_VPR ()
   {
      TRACE_FUN;
      uint16_t row = inputOps [0] ? inputOps [0] : 1;
      row += (posY + 1);
      row = std::max ((uint16_t)1, std::min (row, nRows));
      posY = row - 1;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUP ()
   {
      TRACE_FUN;
      uint16_t row = inputOps [0] ? inputOps [0] : 1;
      uint16_t col = (nInputOps > 1 && inputOps [1]) ? inputOps [1] : 1;
      switch (originMode)
      {
      case OriginMode::Absolute:
         row = std::max ((uint16_t)1, std::min (row, nRows)) - 1;
         break;
      case OriginMode::ScrollingRegion:
         row = std::max ((uint16_t)1, std::min (row, cf->marginBottom)) - 1;
         row += cf->marginTop;
         break;
      }
      col = std::max ((uint16_t)1, std::min (col, nCols)) - 1;

      posX = col;
      posY = row;
      setCur ();
      setState (InputState::Normal);
      logT << "Cursor positioned to (" << posY << "," << posX << ")"
           << std::endl;
   }

   inline void
   Vterm::csi_SU ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      if (horizMarginMode)
      {
         arg = std::min ((int)arg, cf->marginBottom - cf->marginTop);
         deleteRows (cf->marginTop, arg);
      }
      else
      {
         vscrollSelection (-arg);
         for (uint16_t k = 0; k < arg; ++k)
         {
            ++cf->scrollHead;
            if (cf->scrollHead == cf->marginBottom)
               cf->scrollHead = cf->marginTop;
            eraseRow (cf->marginBottom - 1);
         }
         setCur ();
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SD ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      if (horizMarginMode)
      {
         arg = std::min ((int)arg, cf->marginBottom - cf->marginTop);
         insertRows (cf->marginTop, arg);
      }
      else
      {
         vscrollSelection (arg);
         for (uint16_t k = 0; k < arg; ++k)
         {
            if (cf->scrollHead >= cf->marginTop + 1)
               --cf->scrollHead;
            else
               cf->scrollHead = cf->marginBottom - 1;
            eraseRow (cf->marginTop);
         }
         setCur ();
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CHT ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      if (arg == 1)
         inp_HT ();
      else
         for (int k = 0; k < arg; ++k)
            jumpToNextTabStop ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CBT ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      for (uint16_t k = 0; k < arg; ++k)
      {
         if (tabStops.empty ())
         {
            if (posX > 0 && posX % 8 == 0)
               posX -= 8;
            else
               posX = (posX / 8) * 8;
         }
         else
         {
            // Set posX to previous tab stop
            auto ts = std::lower_bound (tabStops.begin (), tabStops.end (), posX);
            if (ts != tabStops.begin ())
               posX = * (--ts);
            else
               posX = 0;
         }
         setCur ();
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_REP ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      for (int k = 0; k < arg; ++k)
         placeGraphicChar ();
      utf8dec.setUnicode (' ');
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ED ()
   {
      TRACE_FUN;
      switch (inputOps [0])
      {
      case 0: // clear from cursor to end of screen
         eraseRange (cur, startOfNextLine ());
         invalidateSelection (Rect (posX, posY, nCols, nRows));
         for (uint16_t pY = posY + 1; pY < nRows; ++pY)
            eraseRow (pY);
         break;
      case 1: // clear from beginning of screen to cursor
         for (uint16_t pY = 0; pY < posY; ++pY)
            eraseRow (pY);
         eraseRange (startOfThisLine (), cur + 1);
         invalidateSelection (Rect (0, 0, posX + 1, posY));
         break;
      case 2: // clear entire screen
         for (uint16_t pY = 0; pY < nRows; ++pY)
            eraseRow (pY);
         invalidateSelection (Rect (0, 0, nCols, nRows));
         break;
      default:
         logI << "Erase in Display with illegal param: "
              << inputOps [0] << std::endl;
         break;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_EL ()
   {
      TRACE_FUN;
      uint32_t begin = cur;
      uint32_t end = cur + 1;
      switch (inputOps [0])
      {
      case 0: // clear from cursor to end of line
         end = startOfNextLine ();
         invalidateSelection (Rect (posX, posY, nCols, posY));
         break;
      case 1: // clear from cursor to beginning of line
         begin = startOfThisLine ();
         invalidateSelection (Rect (0, posY, posX + 1, posY));
         break;
      case 2: // clear entire line
         begin = startOfThisLine ();
         end = startOfNextLine ();
         invalidateSelection (Rect (0, posY, nCols, posY));
         break;
      default:
         logI << "Erase in Line with illegal param: "
              << inputOps [0] << std::endl;
         break;
      }
      eraseRange (begin, end);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_IL ()
   {
      TRACE_FUN;
      if (posY < cf->marginTop || posY >= cf->marginBottom)
      {
         setState (InputState::Normal);
         return;
      }
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, cf->marginBottom - posY);
      insertRows (posY, arg);
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DL ()
   {
      TRACE_FUN;
      if (posY < cf->marginTop || posY >= cf->marginBottom)
      {
         setState (InputState::Normal);
         return;
      }
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, cf->marginBottom - posY);
      deleteRows (posY, arg);
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ICH ()
   {
      TRACE_FUN;
      uint32_t arg = inputOps [0] ? inputOps [0] : 1;
      uint32_t len = nColsEff - posX;
      arg = std::min (arg, len);
      len -= arg;

      if ((* cf) [cur + arg + len - 1].wrap)
      {
         // maintain wrap bit invariance at EOL
         (* cf) [cur + arg + len - 1].wrap = 0;
         (* cf) [cur + len - 1].wrap = 1;
      }
      cf->moveCells (cur + arg, cur, len);
      eraseRange (cur, cur + arg);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DCH ()
   {
      TRACE_FUN;
      uint32_t arg = inputOps [0] ? inputOps [0] : 1;
      uint32_t len = nColsEff - posX;
      arg = std::min (arg, len);
      len -= arg;
      cf->moveCells (cur, cur + arg, len);
      eraseRange (cur + len, cur + len + arg);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ECH ()
   {
      TRACE_FUN;
      uint32_t arg = inputOps [0] ? inputOps [0] : 1;
      uint32_t len = nColsEff - posX;
      arg = std::min (arg, len);
      eraseRange (cur, cur + arg);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_STBM ()
   {
      TRACE_FUN;
      if (nInputOps == 1 && inputOps [0] == 0)
      {
         if (cf->marginTop != 0 || cf->marginBottom != nRows)
         {
            cf->linearizeCellStorage ();
            cf->marginTop = 0;
            cf->marginBottom = nRows;
            cf->scrollHead = 0;
         }
      }
      else if (nInputOps == 2)
      {
         uint16_t newMarginTop = inputOps [0] > 0 ? inputOps [0] - 1 : 0;
         uint16_t newMarginBottom = inputOps [1];

         if (newMarginBottom < newMarginTop + 2 || nRows < newMarginBottom)
         {
            logI << "Illegal arguments to SetTopBottomMargins: top="
                 << inputOps [0] << ", bottom=" << inputOps [1] << std::endl;
         }
         else if (newMarginTop != cf->marginTop || newMarginBottom != cf->marginBottom)
         {
            cf->linearizeCellStorage ();
            cf->marginTop = newMarginTop;
            cf->marginBottom = newMarginBottom;
            cf->scrollHead = cf->marginTop;
         }
      }

      posX = 0;
      posY = cf->marginTop;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SLRM ()
   {
      TRACE_FUN;
      if (nInputOps == 1 && inputOps [0] == 0)
      {
         hMargin = 0;
         nColsEff = nCols;
      }
      else if (nInputOps == 2)
      {
         uint16_t newMarginLeft = inputOps [0] > 0 ? inputOps [0] - 1 : 0;
         uint16_t newMarginRight = inputOps [1];

         if (newMarginRight < newMarginLeft + 2 || nCols < newMarginRight)
         {
            logI << "Illegal arguments to SetLeftRightMargins: left="
                 << inputOps [0] << ", right=" << inputOps [1] << std::endl;
         }
         else if (newMarginLeft != hMargin || newMarginRight != nColsEff)
         {
            hMargin = newMarginLeft;
            nColsEff = newMarginRight;
         }
      }

      posX = 0;
      posY = cf->marginTop;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_TBC ()
   {
      TRACE_FUN;
      switch (inputOps [0])
      {
      case 0:
      {
         auto it = std::find (tabStops.begin (), tabStops.end (), posX);
         if (it != tabStops.end ())
            tabStops.erase (it);
      }
         break;
      case 3:
         tabStops.clear ();
         break;
      default:
         break;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 4: insertMode = true; break;
         case 12: localEcho = false; break;
         case 20: autoNewlineMode = true; break;
         default:
            logU << "set mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_RM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 4: insertMode = false; break;
         case 12: localEcho = true; break;
         case 20: autoNewlineMode = false; break;
         default:
            logU << "reset mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_privSM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 1: cursorKeyMode = CursorKeyMode::Application; break;
         case 2:
            charsetState = CharsetState {};
            compatLevel = CompatibilityLevel::VT400;
            break;
         case 3: switchColMode (ColMode::C132); break;
         case 4: logT << "DECSCLM: Set smooth scroll" << std::endl; break;
         case 5: logU << "DECSCNM: Set inverse video mode" << std::endl; break;
         case 6: originMode = OriginMode::ScrollingRegion; break;
         case 7: autoWrapMode = true; break;
         case 8: logU << "DECARM: Set auto-repeat mode" << std::endl; break;
         case 9: mouseTrk.mode = MouseTrackingMode::X10_Compat; break;
         case 12: logU << "Start blinking cursor" << std::endl; break;
         case 25: showCursorMode = true; break;
         case 47: switchScreenBufferMode (true);  break;
         case 67: bkspSendsDel = false; break;
         case 69: horizMarginMode = true; hMargin = 0; nColsEff = nCols; break;
         case 1000: mouseTrk.mode = MouseTrackingMode::VT200; break;
         case 1001: logU << "Set VT200 Highlight Mouse mode" << std::endl; break;
         case 1002: mouseTrk.mode = MouseTrackingMode::VT200_ButtonEvent; break;
         case 1003: mouseTrk.mode = MouseTrackingMode::VT200_AnyEvent; break;
         case 1004: mouseTrk.focusEventMode = true; break;
         case 1005: mouseTrk.enc = MouseTrackingEnc::UTF8; break;
         case 1006: mouseTrk.enc = MouseTrackingEnc::SGR; break;
         case 1007: altScrollMode = true; break;
         case 1015: mouseTrk.enc = MouseTrackingEnc::URXVT; break;
         case 1047: switchScreenBufferMode (true); break;
         case 1048: esc_DECSC (); break;
         case 1049: esc_DECSC (); switchScreenBufferMode (true); break;
         case 2004: bracketedPasteMode = true; break;
         default:
            logU << "set priv mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_privRM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 1: cursorKeyMode = CursorKeyMode::ANSI; break;
         case 2:
            charsetState = CharsetState {};
            compatLevel = CompatibilityLevel::VT52;
            break;
         case 3: switchColMode (ColMode::C80); break;
         case 4: logT << "DECSCLM: Set jump scroll" << std::endl; break;
         case 5: logU << "DECSCNM: Set normal video mode" << std::endl; break;
         case 6: originMode = OriginMode::Absolute; break;
         case 7: autoWrapMode = false; break;
         case 8: logU << "DECARM: Reset auto-repeat mode" << std::endl; break;
         case 9: case 1000: case 1002: case 1003:
            mouseTrk.mode = MouseTrackingMode::Disabled; break;
         case 12: logU << "Stop blinking cursor" << std::endl; break;
         case 25: showCursorMode = false; break;
         case 47: switchScreenBufferMode (false); break;
         case 67: bkspSendsDel = true; break;
         case 69: horizMarginMode = false; hMargin = 0; nColsEff = nCols; break;
         case 1001: logU << "Reset VT200 Highlight Mouse mode" << std::endl; break;
         case 1004: mouseTrk.focusEventMode = false; break;
         case 1005: case 1006: case 1015:
            mouseTrk.enc = MouseTrackingEnc::Default; break;
         case 1007: altScrollMode = false; break;
         case 1047: switchScreenBufferMode (false); break;
         case 1048: esc_DECRC (); break;
         case 1049: switchScreenBufferMode (false); esc_DECRC (); break;
         case 2004: bracketedPasteMode = false; break;
         default:
            logU << "reset priv mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::setFgFromPalIx ()
   {
      if (fgPalIx < 0)
         *fg = opts.fg;
      else if (attrs.bold && fgPalIx >= 0 && fgPalIx <= 7)
         *fg = palette256 [fgPalIx + 8];
      else
         *fg = palette256 [fgPalIx];
   }

   inline void
   Vterm::setBgFromPalIx ()
   {
      if (bgPalIx < 0)
         *bg = opts.bg;
      else
         *bg = palette256 [bgPalIx];
   }

   inline void
   Vterm::csi_SGR ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& attr = inputOps [k];

         switch (attr)
         {
         case 0:
            attrs.uc_pt = ' ';
            attrs.bold = 0;
            attrs.italic = 0;
            attrs.underline = 0;
            attrs.inverse = 0;
            reverseVideo = false;
            fg = &attrs.fg;
            bg = &attrs.bg;
            fgPalIx = defaultFgPalIx;
            setFgFromPalIx ();
            bgPalIx = defaultBgPalIx;
            setBgFromPalIx ();
            break;
         case 1: attrs.bold = 1; setFgFromPalIx (); break;
         case 2: attrs.bold = 0; setFgFromPalIx (); break;
         case 3: attrs.italic = 1; break;
         case 4: attrs.underline = 1; break;
         case 5: /* blink on */ break;
         case 7:
            if (!reverseVideo)
            {
               fg = &attrs.bg;
               bg = &attrs.fg;
               reverseVideo = true;
               setFgFromPalIx ();
               setBgFromPalIx ();
            }
            break;
         case 8: logU << "attr.: concealed" << std::endl; break;
         case 10: attrs.bold = 0; attrs.italic = 0; setFgFromPalIx (); break;
         case 11: attrs.bold = 1; attrs.italic = 0; setFgFromPalIx (); break;
         case 12: attrs.bold = 0; attrs.italic = 1; setFgFromPalIx (); break;
         case 13: attrs.bold = 1; attrs.italic = 1; setFgFromPalIx (); break;
         case 14: case 15: case 16: case 17: case 18: case 19:
            attrs.bold = 0; attrs.italic = 0; setFgFromPalIx ();
            break;
         case 22: attrs.bold = 0; setFgFromPalIx (); break;
         case 23: attrs.italic = 0; break;
         case 25: /* blink off */ break;
         case 24: attrs.underline = 0; break;
         case 27:
            if (reverseVideo)
            {
               fg = &attrs.fg;
               bg = &attrs.bg;
               reverseVideo = false;
               setFgFromPalIx ();
               setBgFromPalIx ();
            }
            break;
         case 28: logU << "attr.: revealed (conceal off)" << std::endl; break;

         // standard foregrounds (bright if bold)
         case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:
            fgPalIx = attr - 30;
            setFgFromPalIx ();
            break;

         case 38:
            if (k >= nInputOps - 1) break;
            switch (inputOps [++k])
            {
            case 5:
               if (k >= nInputOps - 1) break;
               fgPalIx = inputOps [++k];
               setFgFromPalIx ();
               break;
            case 2:
               if (k >= nInputOps - 3) break;
               (*fg).red   = inputOps [++k];
               (*fg).green = inputOps [++k];
               (*fg).blue  = inputOps [++k];
               break;
            default:
               break;
            }
            break;
         case 39: fgPalIx = defaultFgPalIx; setFgFromPalIx (); break;

         // standard backgrounds
         case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:
            bgPalIx = attr - 40;
            setBgFromPalIx ();
            break;

         case 48:
            if (k >= nInputOps - 1) break;
            switch (inputOps [++k])
            {
            case 5:
               if (k >= nInputOps - 1) break;
               bgPalIx = inputOps [++k];
               setBgFromPalIx ();
               break;
            case 2:
               if (k >= nInputOps - 3) break;
               (*bg).red   = inputOps [++k];
               (*bg).green = inputOps [++k];
               (*bg).blue  = inputOps [++k];
               break;
            default:
               break;
            }
            break;
         case 49: bgPalIx = defaultBgPalIx; setBgFromPalIx (); break;

         // bright colored foregrounds
         case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:
            fgPalIx = attr - 82;
            setFgFromPalIx ();
            break;

         // bright colored backgrounds
         case 100: case 101: case 102: case 103: case 104: case 105: case 106:
         case 107:
            bgPalIx = attr - 92;
            setBgFromPalIx ();
            break;

         default:
            logU << "attribute: " << attr << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   /* 64 - VT420 family
    *  1 - 132 columns
    *  9 - National Replacement Character-sets
    * 15 - DEC technical set
    * 21 - horizontal scrolling
    * 22 - color
    */
   #define DEVICE_ID "64;1;9;15;21;22c"

   inline void
   Vterm::csi_priDA ()
   {
      TRACE_FUN;
      writePty ("\e[?" DEVICE_ID);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_secDA ()
   {
      TRACE_FUN;
      writePty ("\e[>64;0;0c"); // VT520
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DSR ()
   {
      TRACE_FUN;
      switch (inputOps [0])
      {
      case 5:
         writePty ("\e[0n"); // device OK
         break;
      case 6:
      {
         std::ostringstream oss;
         if (originMode == OriginMode::Absolute)
            oss << "\e[" << (posY + 1) << ";" << (posX + 1) << "R";
         else
            oss << "\e[" << (posY - cf->marginTop + 1) << ";" << (posX + 1) << "R";
         writePty (oss.str ().c_str ());
      }
         break;
      default:
         break;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::esch_DECALN ()
   {
      TRACE_FUN;

      // Save current attrs
      CharVdev::Cell origAttrs = attrs;
      Color* origFg = &attrs.fg;
      Color* origBg = &attrs.bg;

      resetAttrs ();
      fillScreen ('E');

      // Restore attrs
      fg = origFg;
      bg = origBg;
      attrs = origAttrs;

      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_RIS ()
   {
      TRACE_FUN;
      resetTerminal ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DECSTR ()
   {
      TRACE_FUN;
      resetScreen ();
      resetAttrs ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::handle_DCS ()
   {
      TRACE_FUN;
      auto arg = std::string ((char*)argBuf.data (), argBuf.size ());
      if (arg == "$q\"p")
      {
         // DECSCL
         if (compatLevel == CompatibilityLevel::VT400)
            writePty ("\eP1$r" DEVICE_ID "\e\\");
      }
      else
      {
         logU << "DCS: '" << arg << "'" << std::endl;
         std::ostringstream oss;
         oss << "\eP0$r";
         oss << arg.substr (2);
         oss << "\e\\";
         writePty (oss.str ().c_str ());
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::handle_OSC ()
   {
      TRACE_FUN;
      auto osc = std::string ((char*)argBuf.data (), argBuf.size ());
      std::stringstream iss (osc);
      int cmd;
      char sep;
      iss >> cmd >> sep;
      if (iss.fail () || sep != ';')
      {
         logT << "OSC: malformed command string'" << osc << "'" << std::endl;
      }
      else
      {
         std::string arg = osc.substr (iss.tellg ());
         switch (cmd)
         {
         // Add cases here for OSC commands internally handled by vterm

         // Other cases handed over to external OSC handler:
         default: onOsc (cmd, arg); break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csiq_DECSCL ()
   {
      TRACE_FUN;
      if (nInputOps > 0)
      {
         switch (inputOps [0])
         {
         case 61: compatLevel = CompatibilityLevel::VT100; break;
         case 62: compatLevel = CompatibilityLevel::VT400; break;
         case 63: compatLevel = CompatibilityLevel::VT400; break;
         case 64: compatLevel = CompatibilityLevel::VT400; break;
         case 65: compatLevel = CompatibilityLevel::VT400; break;
         default:
            logU << "DECSCL: compatibility mode " << inputOps [0] << std::endl;
            break;
         }
      }
      if (nInputOps > 1)
      {
         switch (inputOps [1])
         {
         case 0: logT << "DECSCL: 8-bit controls" << std::endl; break;
         case 1: logT << "DECSCL: 7-bit controls" << std::endl; break;
         case 2: logT << "DECSCL: 8-bit controls" << std::endl; break;
         default:
            logU << "DECSCL: C1 control transmission mode: "
                 << inputOps [1] << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_XTWINOPS ()
   {
      TRACE_FUN;
      // ignore
      setState (InputState::Normal);
   }

} // namespace zutty
